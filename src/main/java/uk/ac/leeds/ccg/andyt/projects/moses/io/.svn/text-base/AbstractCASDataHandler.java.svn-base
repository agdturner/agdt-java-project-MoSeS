/**
 * A component of a library for
 * <a href="http://www.geog.leeds.ac.uk/people/a.turner/projects/MoSeS">MoSeS</a>.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
 */
package uk.ac.leeds.ccg.andyt.projects.moses.io;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.io.StreamTokenizer;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.TreeMap;
import java.util.TreeSet;
import uk.ac.leeds.ccg.andyt.generic.io.Generic_StaticIO;
import uk.ac.leeds.ccg.andyt.generic.core.Generic_ErrorAndExceptionHandler;
import uk.ac.leeds.ccg.andyt.generic.utilities.Generic_Collections;

/**
 * For handling <code>AbstractCASDataRecords</code>.
 * @version 1.0.0, 2006-08-10
 * @see AbstractCASDataRecord
 */
public abstract class AbstractCASDataHandler
        extends AbstractDataHandler {

    /**
     * CAS001DataHandler
     */
    protected CAS001DataHandler _CAS001DataHandler;

    /**
     * Returns this._CAS001DataHandler
     */
    public CAS001DataHandler getCAS001DataHandler() {
        return this._CAS001DataHandler;
    }
    /**
     * CAS003DataHandler
     */
    protected CAS003DataHandler _CAS003DataHandler;

    /**
     * Returns this._CAS003DataHandler
     */
    public CAS003DataHandler getCAS003DataHandler() {
        return this._CAS003DataHandler;
    }
    /**
     * For storing a one to one mapping of:
     * <code>long AbstractCASDataRecord.RecordID</code> as keys and
     * <code>String Zone Code</code> as values.
     */
    protected HashMap _RecordIDZoneCodeHashMap;
    /**
     * For storing a look up table for converting from OA to MSOA Zone Code
     */
    protected HashMap _LookUpMSOAfromOAHashMap;

    /**
     * @return An <code>AbstractCASDataRecord</code> for the given RecordID
     * @param RecordID
     *            The RecordID of the <code>AbstractCASDataRecord</code> to be
     *            returned.
     */
    @Override
    public abstract AbstractCASDataRecord getDataRecord(long RecordID);

    /**
     * @return An <code>AbstractCASDataRecord</code> for the given zoneCode if
     *         it exists or null otherwise.
     * @param aZoneCode
     *            A <code>String</code> representation of an
     *            <code>AbstractCASDataRecord.Zone_Code</code> for the
     *            <code>AbstractCASDataRecord</code> to be returned.
     */
    public AbstractCASDataRecord getDataRecord(String aZoneCode) {
        if (getRecordIDZoneCodeHashMap() == null) {
            // Initialise
            File _RecordIDZoneCodeHashMapObjectFile = new File(
                    get_Directory(),
                    "RecordIDZoneCodeHashMap.thisFile");
            if (_RecordIDZoneCodeHashMapObjectFile.exists()) {
                this._RecordIDZoneCodeHashMap = (HashMap) Generic_StaticIO.readObject(_RecordIDZoneCodeHashMapObjectFile);
            } else {
                // If not on disc create
                this._RecordIDZoneCodeHashMap = new HashMap();
                long RecordID;
                long nRecords = getNDataRecords();
                for (RecordID = 0L; RecordID < nRecords; RecordID++) {
                    this._RecordIDZoneCodeHashMap.put(RecordID, new String(
                            getDataRecord(RecordID).getZone_Code()));
                }
                // Store on disc for future reference
                try {
                    _RecordIDZoneCodeHashMapObjectFile.createNewFile();
                } catch (IOException aIOException) {
                    log(aIOException.getLocalizedMessage());
                    System.exit(Generic_ErrorAndExceptionHandler.IOException);
                }
                Generic_StaticIO.writeObject(
                        this._RecordIDZoneCodeHashMap,
                        _RecordIDZoneCodeHashMapObjectFile);
            }
        }
        Iterator iterator = this._RecordIDZoneCodeHashMap.keySet().iterator();
        Object key;
        Object value;
        String bZoneCode;
        while (iterator.hasNext()) {
            key = iterator.next();
            value = this._RecordIDZoneCodeHashMap.get(key);
            bZoneCode = (String) value;
            // System.out.println("aZoneCode " + aZoneCode + " , bZoneCode " +
            // bZoneCode);
            // System.out.println("aZoneCode.length() " + aZoneCode.length() +
            // " , bZoneCode.length() " + bZoneCode.length() );
            if (bZoneCode.startsWith(aZoneCode)) {
                // if ( bZoneCode.equalsIgnoreCase( aZoneCode ) ) {
                return getDataRecord((Long) key);
            }
        }
        return null;
    }

    /**
     * @return An <code>AbstractCASDataRecord</code> for the given Zone_Code if
     *         it exists or null otherwise.
     * @param Zone_Code
     *            A <code>AbstractCASDataRecord.Zone_Code</code> for the
     *            <code>AbstractCASDataRecord</code> to be returned.
     */
    protected AbstractCASDataRecord getDataRecord(char[] Zone_Code)
            throws IOException {
        return getDataRecord(new String(Zone_Code));
    }

    /**
     * @return <code>this.tRecordIDZoneCodeHashMap</code>
     */
    protected HashMap getRecordIDZoneCodeHashMap() {
        if (this._RecordIDZoneCodeHashMap == null) {
            initRecordIDZoneCode_HashMap();
        }
        return this._RecordIDZoneCodeHashMap;
    }

    /**
     * @return deep copy of <code>this.tRecordIDZoneCodeHashMap</code>
     */
    public HashMap getRecordIDZoneCode_HashMap() {
        return Generic_Collections.deepCopy_Long_String(getRecordIDZoneCodeHashMap());
    }

    private void initRecordIDZoneCode_HashMap() {
        _RecordIDZoneCodeHashMap = new HashMap();
        long n = getNDataRecords();
        for (long recordID = 0; recordID < n; recordID ++) {
            _RecordIDZoneCodeHashMap.put(
                    recordID, 
                    new String(this._CAS001DataHandler.getCAS001DataRecord(recordID).Zone_Code));
        }
    }

    /**
     * @return <code>this.tRecordIDZoneCodeHashMap</code> with keys and values 
     * deep copied and swapped around
     */
    public HashMap getZoneCodeRecordID_HashMap() {
        HashMap<String, Long> result = new HashMap<String, Long>();
        Iterator<Long> ite = getRecordIDZoneCodeHashMap().keySet().iterator();
        Long keyToCopy;
        Long keyCopy;
        String valueToCopy;
        String valueCopy;
        while (ite.hasNext()) {
            keyToCopy = ite.next();
            keyCopy = new Long(keyToCopy);
            valueToCopy = (String) this._RecordIDZoneCodeHashMap.get(keyToCopy);
            valueCopy = valueToCopy;
            result.put(valueCopy, keyCopy);
        }
        return result;
    }

    // /**
    // * Formats the inputFile containing the
    // <code>AbstractCASDataRecords</code>.
    // * @param inputFile The <code>File</code> containing the
    // <code>AbstractCASDataRecords</code>.
    // * @param RecordID The <code>RecordID</code> to assign to the first
    // <code>AbstractCASDataRecord</code> loaded.
    // * @return The <code>RecordID</code> assigned to the last
    // <code>AbstractCASDataRecord</code> loaded.
    // */
    // protected abstract long format(
    // File inputFile,
    // long RecordID )
    // throws IOException;
    //
    // /**
    // * For parsing a line from a source file and handling
    // handleOutOfMemoryError.
    // * @param RecordID The RecordID
    // * @param line A string representation of the line of the file.
    // * @param handleOutOfMemoryError If true then an attempt is made
    // * to handle OutOfMemoryErrors.
    // */
    // public AbstractCASDataRecord parseLine(
    // long RecordID,
    // String line,
    // boolean handleOutOfMemoryError )
    // throws IOException {
    // return parseLine( RecordID, line );
    // }
    //
    // /**
    // * Parses a line from the source CASKeyStatisticSelection1 file.
    // * @param RecordID The RecordID
    // * @param line A string representation of the line of the file.
    // */
    // protected abstract AbstractCASDataRecord parseLine(
    // long RecordID,
    // String line )
    // throws IOException;
    /**
     * TODO docs
     */
    public HashMap get_LookUpMSOAfromOAHashMap() {
        if (this._LookUpMSOAfromOAHashMap == null) {
            // Initialise
            File _LookUpMSOAfromOAHashMapObjectFile = new File(get_Directory(),
                    "LookUpMSOAfromOAHashMap.thisFile");
            if (_LookUpMSOAfromOAHashMapObjectFile.exists()) {
                this._LookUpMSOAfromOAHashMap = (HashMap) Generic_StaticIO.readObject(_LookUpMSOAfromOAHashMapObjectFile);
            } else {
                // If not on disc create
                this._LookUpMSOAfromOAHashMap = new HashMap();
                // Load look up table
                File lookUpTableFile = new File(
                        "C:/Work/data/Census/2001/LUTs/OA_LSOA_MSOA_LA_Apr05_txt/OA_LSOA_MSOA_LA_Apr05.txt");
                try {
                    BufferedReader aBufferedReader = new BufferedReader(
                            new InputStreamReader(new FileInputStream(
                            lookUpTableFile)));
                    StreamTokenizer aStreamTokenizer = new StreamTokenizer(
                            aBufferedReader);
                    Generic_StaticIO.setStreamTokenizerSyntax1(aStreamTokenizer);
                    String line;
                    Object[] codes = null;
                    boolean print = false;
                    boolean boolean0 = false;
                    int int1000 = 1000;
                    int int0 = 0;
                    // Skip the first line
                    int tokenType = aStreamTokenizer.nextToken();
                    while (tokenType != StreamTokenizer.TT_EOL) {
                        tokenType = aStreamTokenizer.nextToken();
                    }
                    tokenType = aStreamTokenizer.nextToken();
                    while (tokenType != StreamTokenizer.TT_EOF) {
                        switch (tokenType) {
                            case StreamTokenizer.TT_EOL:
                                this._LookUpMSOAfromOAHashMap.put(codes[0],
                                        codes[1]);
                                if (int0 % int1000 == 0 && print) {
                                    System.out.println("loaded " + int0 + " look ups");
                                }
                                break;
                            case StreamTokenizer.TT_WORD:
                                int0++;
                                line = aStreamTokenizer.sval;
                                codes = parseLine(line);
                                break;
                        }
                        tokenType = aStreamTokenizer.nextToken();
                    }
                } catch (IOException aIOException) {
                    aIOException.printStackTrace();
                }
                // Store on disc for future reference
                try {
                    _LookUpMSOAfromOAHashMapObjectFile.createNewFile();
                    Generic_StaticIO.writeObject(
                            this._LookUpMSOAfromOAHashMap,
                            _LookUpMSOAfromOAHashMapObjectFile);
                } catch (IOException aIOException) {
                    aIOException.printStackTrace();
                }
            }
        }
        return this._LookUpMSOAfromOAHashMap;
    }

    /**
     * TODO docs
     */
    protected static Object[] parseLine(String line) {
        Object[] result = new Object[2];
        String[] fields = line.split("\",\"");
        if (fields.length < 7) {
            if (fields.length < 3) {
                // Handle line with " Neston" on
                boolean DEBUG = true;
            } else {
                // Handle Ellesmere Port 13UEFU0001 E01018518
                // Something strange is going on...
                // Perhaps there are extra end of line markers in the record...
                if (fields[0].substring(1).equalsIgnoreCase("13UEFU0001")) {
                    System.out.println("Strange case of Ellesmere Port");
                } else {
                    if (fields[2].substring(1).equalsIgnoreCase(
                            "Ellesmere Port ")) {
                        System.out.println("Strange case of Ellesmere Port");
                    } else {
                        boolean DEBUG = true;
                    }
                }
            }
            boolean DEBUG = true;
        } else {
            if (fields.length > 7) {
                boolean DEBUG = true;
            } else {
                result[0] = fields[0].substring(1);
                result[1] = fields[3];
            }
        }
        return result;
    }

    /**
     * For checking OA MSOA Codes
     *
     * @param startRecordID
     *            The RecordID of the first OA code to check
     * @param endRecordID
     *            The RecordID of the last OA code to check
     */
    public void printOAMSOACodes(
            long startRecordID,
            long endRecordID)
            throws Exception {
        HashMap lookUpMSOAfromOAHashMap = get_LookUpMSOAfromOAHashMap();
        CASDataHandler aCASDataHandler = new CASDataHandler();
        AbstractCASDataRecord aCASDataRecord;
        String zoneCode;
        for (long RecordID = startRecordID; RecordID < endRecordID; RecordID++) {
            aCASDataRecord = (CASDataRecord) aCASDataHandler.getDataRecord(RecordID);
            zoneCode = new String(aCASDataRecord.getZone_Code());
            System.out.println("OA " + zoneCode + " MSOA " + (String) lookUpMSOAfromOAHashMap.get(zoneCode));
        }
    }

    public TreeSet<String> getLADCodes_TreeSet()
            throws IOException {
        TreeSet<String> tLADCodes;
        File tLADCodeTreeSet_File = new File(
                _Directory,
                "LADCodes_TreeSet.thisFile");
        if (tLADCodeTreeSet_File.exists()) {
            tLADCodes = (TreeSet) Generic_StaticIO.readObject(tLADCodeTreeSet_File);
        } else {
            tLADCodes = new TreeSet();
            AbstractCASDataRecord aCASDataRecord;
            String aLADCode;
            for (long RecordID = 0; RecordID < getNDataRecords(); RecordID++) {
                aCASDataRecord = getDataRecord(RecordID);
                aLADCode = new String(aCASDataRecord.getZone_Code()).substring(0, 4);
                if (!tLADCodes.contains(aLADCode)) {
                    tLADCodes.add(aLADCode);
                }
            }
            Generic_StaticIO.writeObject(tLADCodes, tLADCodeTreeSet_File);
        }
        return tLADCodes;
    }

    /**
     *
     * @return A TreeSet<String> of all OA Codes in the UK.
     */
    public TreeSet<String> getOACodes_TreeSet() {
        TreeSet<String> tOACodes;
        File tOACodeTreeSet_File = new File(
                _Directory,
                "OACodes_TreeSet.thisFile");
        if (tOACodeTreeSet_File.exists()) {
            tOACodes = (TreeSet<String>) Generic_StaticIO.readObject(tOACodeTreeSet_File);
        } else {
            tOACodes = new TreeSet();
            AbstractCASDataRecord aCASDataRecord;
            String aOACode;
            for (long RecordID = 0; RecordID < getNDataRecords(); RecordID++) {
                aCASDataRecord = getDataRecord(RecordID);
                aOACode = new String(aCASDataRecord.getZone_Code());
                if (!tOACodes.contains(aOACode)) {
                    tOACodes.add(aOACode);
                }
            }
            Generic_StaticIO.writeObject(tOACodes, tOACodeTreeSet_File);
        }
        return tOACodes;
    }

    /**
     * @return A HashSet<String> of all OA Codes in the UK.
     */
    public HashSet<String> getOACodes_HashSet() {
        HashSet<String> tOACodes;
        File tOACodeHashSet_File = new File(
                _Directory,
                "OACodes_HashSet.thisFile");
        if (tOACodeHashSet_File.exists()) {
            tOACodes = (HashSet<String>) Generic_StaticIO.readObject(tOACodeHashSet_File);
        } else {
            tOACodes = new HashSet();
            AbstractCASDataRecord aCASDataRecord;
            String aOACode;
            for (long RecordID = 0; RecordID < getNDataRecords(); RecordID++) {
                aCASDataRecord = getDataRecord(RecordID);
                aOACode = new String(aCASDataRecord.getZone_Code());
                if (!tOACodes.contains(aOACode)) {
                    tOACodes.add(aOACode);
                }
            }
            Generic_StaticIO.writeObject(tOACodes, tOACodeHashSet_File);
        }
        return tOACodes;
    }

    /**
     * @param startOfOACodes_String
     * @return A HashSet<String> of Output Area Codes that start with
     * startOfOACodes_String
     */
    public HashSet getOACodes_HashSet(
            String startOfOACodes_String) {
        HashSet<String> result = new HashSet<String>();
        HashSet<String> tOACodes_HashSet = getOACodes_HashSet();
        Iterator<String> a_Iterator = tOACodes_HashSet.iterator();
        String areaCode_String;
        while (a_Iterator.hasNext()) {
            areaCode_String = a_Iterator.next();
            if (areaCode_String.startsWith(startOfOACodes_String)) {
                result.add(areaCode_String);
            }
        }
        return result;
    }

    /**
     * Writes aggregateOAToMSOA to aRandomAccessFile
     *
     * @param aRandomAccessFile
     * @param aggregateOAToMSOA
     */
    public void write(
            RandomAccessFile aRandomAccessFile,
            TreeMap aggregateOAToMSOA) throws IOException {
        Iterator aIterator = aggregateOAToMSOA.keySet().iterator();
        Object key;
        long RecordID = -1L;
        int hashCode = -1;
        while (aIterator.hasNext()) {
            key = aIterator.next();
            Object aObject = aggregateOAToMSOA.get(key);
            RecordID++;
            hashCode++;
            if (aObject instanceof CAS001DataRecord) {
                ((CAS001DataRecord) aObject).write(aRandomAccessFile, RecordID,
                        hashCode, (String) key);
            }
            if (aObject instanceof CAS002DataRecord) {
                ((CAS002DataRecord) aObject).write(aRandomAccessFile, RecordID,
                        hashCode, (String) key);
            }
            if (aObject instanceof CAS003DataRecord) {
                ((CAS003DataRecord) aObject).write(aRandomAccessFile, RecordID,
                        hashCode, (String) key);
            }
            if (aObject instanceof CAS044DataRecord) {
                ((CAS044DataRecord) aObject).write(aRandomAccessFile, RecordID,
                        hashCode, (String) key);
            }
            if (aObject instanceof CASKS002DataRecord) {
                ((CASKS002DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS006DataRecord) {
                ((CASKS006DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS008DataRecord) {
                ((CASKS008DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS09bDataRecord) {
                ((CASKS09bDataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS09cDataRecord) {
                ((CASKS09cDataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS010DataRecord) {
                ((CASKS010DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS12bDataRecord) {
                ((CASKS12bDataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS12cDataRecord) {
                ((CASKS12cDataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS013DataRecord) {
                ((CASKS013DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS14bDataRecord) {
                ((CASKS14bDataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS14cDataRecord) {
                ((CASKS14cDataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS015DataRecord) {
                ((CASKS015DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS017DataRecord) {
                ((CASKS017DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS020DataRecord) {
                ((CASKS020DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASKS023DataRecord) {
                ((CASKS023DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
            if (aObject instanceof CASUV003DataRecord) {
                ((CASUV003DataRecord) aObject).write(aRandomAccessFile,
                        RecordID, hashCode, (String) key);
            }
        }
    }
}
